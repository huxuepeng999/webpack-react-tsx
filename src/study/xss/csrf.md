## 定义

跨站点请求伪造（也称为 CSRF）是一种 web 安全漏洞，允许攻击者诱使用户执行他们不打算执行的操作。它允许攻击者部分绕过同源策略，该策略旨在防止不同网站相互干扰

## CSRF 是如何工作的

### 要使 CSRF 攻击成为可能，必须具备三个关键条件

相关行动。应用程序中存在攻击者有理由诱导的操作。这可能是一个特权操作（例如修改其他用户的权限）或对用户特定数据的任何操作（例如更改用户自己的密码）
基于 Cookie 的会话处理。执行该操作涉及发出一个或多个 HTTP 请求，应用程序仅依赖会话 cookie 来识别发出请求的用户。没有其他机制用于跟踪会话或验证用户请求
没有不可预测的请求参数。执行该操作的请求不包含攻击者无法确定或猜测其值的任何参数。例如，当导致用户更改密码时，如果攻击者需要知道现有密码的值，则该函数不易受攻击

### demo

用户登录了站点 A，站点 A 给用户签发了 session cookie，用来表示当前的用户身份
用户在未登出的状态下，访问了攻击者制作的恶意站点 B
站点 B 中，攻击者悄悄向站点 A 发送了请求。浏览器筛选出用户在站点 A 下的 cookie，随请求一起发送
站点 A 服务端应用收到请求，取出用户的 session cookie，校验通过，执行对应的操作

## csrf token

服务端发送 token 给浏览器，浏览器在请求中携带该 token 参数。
服务端取出该参数：判断该 token 参数是否有效，并判断是否跟 user cookie 指向同一用户。
那这就有 2 个问题

### 服务端如何将 token 传给客户端？可以通过如下几种方式：

cookie（不要设置 HttpOnly，需要让浏览器端可读取）
HTTP response Header
隐藏表单 / 隐藏元素 / meta tag
通过请求获取

### 客户端将 token 添加在哪里，随请求一起发送给服务端？

HTTP request Header: 建议将 token 添加在 header 中发送，它具有一个天然的优势，可以利用浏览器的同源策略：csrf token header 相当于一个自定义 header，在跨域请求时，携带自定义 header，会触发预检请求，若预检请求不通过，正式请求就不会发送
